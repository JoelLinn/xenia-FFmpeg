import os
import re

template_header = """
-----------------------------------------------------------------------
---- Automatically generated by generate_premake.py. Do not edit ! ----
-----------------------------------------------------------------------

project("{}")
  uuid("{}")
  kind("StaticLib")
  language("C")
  ffmpeg_common()
"""

templates = {}
templates['libavutil'] = template_header.format('libavutil', '19216035-F781-4F15-B009-213B7E3A18AC') + """
  filter("platforms:Windows")
    buildoptions({
      "/wd4018", -- signed/unsigned mismatch
      "/wd4028", -- formal parameter 3 different from declaration
      "/wd4090", -- different const qualifiers
      "/wd4101", -- unreferenced local variable
      "/wd4133", -- incompatible types
      "/wd4146", -- unary minus operator applied to unsigned type, result still unsigned
      "/wd4244", -- conversion 'x' to 'x', possible loss of data
      "/wd4267", -- 'initializing': conversion from 'x' to 'x', possible loss of data
      "/wd4305", -- 'initializing': truncation from 'x' to 'x'
      "/wd4333", -- right shift by too large amount, data loss
      "/wd4554", -- check operator precedence for possible error
    })
  filter("platforms:Linux")
    buildoptions({
      "-Wno-error=implicit-const-int-float-conversion",
      "-Wno-error=incompatible-pointer-types-discards-qualifiers",
      "-Wno-error=switch",
      "-Wno-error=incompatible-pointer-types",
      "-Wno-error=logical-op-parentheses",
      "-Wno-error=pointer-sign",
      "-Wno-error=parentheses",
      "-Wno-error=string-plus-int",
      "-Wno-error=tautological-constant-out-of-range-compare",
    })
  filter {}

"""

templates['libavcodec'] =  template_header.format('libavcodec', '9DB2830C-D326-48ED-B4CC-08EA6A1B7272') + """
  filter("platforms:Windows")
    buildoptions({
      "/wd4003", --	not enough arguments for function-like macro invocation
      "/wd4013", -- undefined; assuming extern returning int
      "/wd4018", -- signed/unsigned mismatch
      "/wd4028", -- formal parameter 3 different from declaration
      "/wd4047", -- 'initializing': 'x' differs in levels of indirection from 'x'
      "/wd4087",
      "/wd4089", -- different types in actual parameter x, formal parameter x
      "/wd4090", -- different const qualifiers
      "/wd4101", -- unreferenced local variable
      "/wd4113",
      "/wd4133", -- incompatible types
      "/wd4146", -- unary minus operator applied to unsigned type, result still unsigned
      "/wd4244", -- conversion 'x' to 'x', possible loss of data
      "/wd4267", -- 'initializing': conversion from 'x' to 'x', possible loss of data
      "/wd4305", -- 'initializing': truncation from 'x' to 'x'
      "/wd4334", -- result of 32-bit shift implicitly converted to 64 bits
      "/wd4554", -- check operator precedence for possible error
      "/wd4996", -- was declared deprecated
    })
  filter("platforms:Linux")
    buildoptions({
      "-Wno-error=implicit-const-int-float-conversion",
      "-Wno-error=incompatible-pointer-types-discards-qualifiers",
      "-Wno-error=switch",
      "-Wno-error=incompatible-pointer-types",
      "-Wno-error=pointer-sign",
      "-Wno-error=parentheses",
      "-Wno-error=string-plus-int",
      "-Wno-error=deprecated-declarations",
    })
  filter {}
  links({
    "libavutil",
  })

"""

# gets the config defines from the generated header
def get_conf():
    conf = {}
    # platform configs mostly differ in HAVE_*, which we are not interested in
    with open('config_win.h', 'r') as c:
        for line in c:
            split = line.rstrip().split(' ' , 2)
            if len(split) != 3:
                continue
            if split[0] != '#define':
                continue
            key = split[1]
            val = split[2]
            if val[0] == '"' and val[-1] == '"':
                val = val[1:-1]
            else:
                try:
                    val = int(val)
                except ValueError:
                    pass
            conf[key] = val
    return conf

# Adapted from distutils.sysconfig.parse_makefile
# Regexes needed for parsing Makefile (and similar syntaxes,
# like old-style Setup files).
_variable_rx = re.compile(r"([a-zA-Z][a-zA-Z0-9\-_]+)\s*(\+?)=\s*(.*)")
_variable_conditional_rx = re.compile(r"([a-zA-Z][a-zA-Z0-9\-_]+)-\$\(([a-zA-Z][a-zA-Z0-9\-_]+)\)\s*(\+?)=\s*(.*)")
_findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9\-_]*)\)")
_findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9\-_]*)}")
def parse_makefile(fn, conf, g=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    from distutils.text_file import TextFile
    fp = TextFile(fn, strip_comments=1, skip_blanks=1, join_lines=1, errors="surrogateescape")

    if g is None:
        g = {}
    done = {}
    notdone = {}

    while True:
        line = fp.readline()
        if line is None: # eof
            break
        n = cond = app = v = None
        m = _variable_rx.match(line)
        if m:
            n, app, v = m.group(1, 2, 3)
        else:
            m = _variable_conditional_rx.match(line)
            if m:
                n, cond, app, v = m.group(1, 2, 3, 4)

        if v:
            v = v.strip()

            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', '')


            if cond:
                boolean = cond in conf and conf[cond]
                n += ('-yes' if boolean else '-no')

            if "$" in tmpv:
                notdone[n] = v
            else:
                v = v.replace('$$', '$')
                if app:
                    if n not in done:
                        done[n] = v
                    else:
                        done[n] += ' ' + v
                else:
                    done[n] = v

    # hacky. just assume they were all +=
    notdone_done = {}
    # do variable interpolation here
    while notdone:
        for name in list(notdone):
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m:
                n = m.group(1)
                found = True
                if n in done:
                    item = str(done[n])
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n]

                else:
                    notdone_done[n] = item = ""
                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        notdone_done[name] = value
                        del notdone[name]
            else:
                # bogus variable reference; just drop it since we can't deal
                del notdone[name]
    for k in notdone_done:
        if k in done:
            done[k] += ' ' + notdone_done[k]
        else:
            done[k] = notdone_done[k]

    fp.close()

    # strip spurious spaces
    for k, v in done.items():
        if isinstance(v, str):
            done[k] = v.strip()

    # save the results in the global dictionary
    g.update(done)
    return g


def premake_files(files):
    s = '  files({\n'
    for f in files:
        # will break on asm files
        f = re.sub('.o$', '.c', f)
        s += '    "{}",\n'.format(f)
    s += '  })\n'
    return s


def generate_premake(conf, libname):
    M = 'Makefile'
    makefiles = [
        os.path.join(libname, M),
        os.path.join(libname, 'aarch64', M),
        os.path.join(libname, 'x86', M),
    ]
    with open(os.path.join(libname, 'premake5.lua'), 'w') as premake:
        premake.write(templates[libname])
        files = []
        for makefile in makefiles:
            m = parse_makefile(makefile, conf)
            file_blocks = [
                'HEADERS',
                'ARCH_HEADERS',
                'BUILT_HEADERS',
                'OBJS',
                'MMX-OBJS',
            ]
            for file_block in file_blocks:
                for _ in range(2):
                    if file_block in m:
                        premake.write('  -- {}:\n'.format(makefile.replace('\\', '/')))
                        premake.write('  --   {}:\n'.format(file_block))
                        premake.write(premake_files(m[file_block].split()))
                    file_block += '-yes'


if __name__ == '__main__':
    conf =get_conf()
    for libname in templates:
        generate_premake(conf, libname)
